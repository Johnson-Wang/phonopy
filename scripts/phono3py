#!/usr/bin/env python

# Copyright (C) 2011 Atsushi Togo
# All rights reserved.
#
# This file is part of phonopy.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
# * Redistributions of source code must retain the above copyright
#   notice, this list of conditions and the following disclaimer.
#
# * Redistributions in binary form must reproduce the above copyright
#   notice, this list of conditions and the following disclaimer in
#   the documentation and/or other materials provided with the
#   distribution.
#
# * Neither the name of the phonopy project nor the names of its
#   contributors may be used to endorse or promote products derived
#   from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.

import os
import sys
import numpy as np
from datetime import datetime
from optparse import OptionParser
from anharmonic import Cutoff

from phonopy.interface.vasp import read_vasp
from phonopy.structure.cells import get_supercell, Primitive, print_cell
from phonopy.structure.symmetry import Symmetry
from phonopy.harmonic.force_constants import get_force_constants, \
    set_permutation_symmetry, set_translational_invariance, show_drift_force_constants
from phonopy.file_IO import parse_BORN
from phonopy.units import VaspToTHz
from anharmonic.phonon3.fc3 import get_fc3, set_permutation_symmetry_fc3, \
    set_translational_invariance_fc3, show_drift_fc3,cutoff_fc3_by_zero, cutoff_fc3
from anharmonic.file_IO import parse_disp_fc3_yaml, write_FORCES_THIRD,\
    parse_DELTA_FORCES, write_supercells_with_displacements,\
    write_DELTA_FC2_SETS, parse_DELTA_FC2_SETS, parse_FORCES_SECOND, \
    write_fc3_to_hdf5, write_fc2_to_hdf5,\
    read_fc3_from_hdf5, read_fc2_from_hdf5, write_ir_grid_points,\
    write_triplets
from anharmonic.phonon3.triplets import get_coarse_ir_grid_points, get_triplets_at_q, get_nosym_triplets_at_q
from anharmonic.phonon3.interaction import Interaction
from anharmonic.phonon3.displacement_fc3 import get_third_order_displacements, direction_to_displacement
from anharmonic.settings import Phono3pyConfParser
from anharmonic.phonon3 import Phono3py, JointDOS, get_gruneisen_parameters, Phono3pyIsotope

phono3py_version = "1.1.7"

# AA is created at http://www.network-science.de/ascii/.

def print_phono3py(time=None):
    print " ".join(sys.argv)
    print """        _                      _____             
  _ __ | |__   ___  _ __   ___|___ / _ __  _   _ 
 | '_ \| '_ \ / _ \| '_ \ / _ \ |_ \| '_ \| | | |
 | |_) | | | | (_) | | | | (_) |__) | |_) | |_| |
 | .__/|_| |_|\___/|_| |_|\___/____/| .__/ \__, |
 |_|                                |_|    |___/ """
    if time:
        print "Program begins at", str(time)
    
def file_exists(filename, log_level):
    if os.path.exists(filename):
        return True
    else:
        error_text = "%s not found." % filename
        print_error_message(error_text)
        if log_level > 0:
            print_error()
        sys.exit(1)

def print_version(version):
    print " " * 42, version
    print ""

def print_end(time =None):
    if time:
        print "Program ends at:", str(time)
    print """                 _
   ___ _ __   __| |
  / _ \ '_ \ / _` |
 |  __/ | | | (_| |
  \___|_| |_|\__,_|
"""

def print_error():
    print """  ___ _ __ _ __ ___  _ __
 / _ \ '__| '__/ _ \| '__|
|  __/ |  | | | (_) | |
 \___|_|  |_|  \___/|_|
"""

def print_error_message(message):
    print message

# Parse options
parser = OptionParser()
parser.set_defaults(amplitude=None,
                    band_indices=None,
                    band_paths=None,
                    band_points=None,
                    cell_poscar=None,
                    cutoff_pair_distance=None,
                    cutoff_delta=None,
                    cutoff_triplet=None,
                    cutoff_frequency=1e-2,
                    cutoff_hfrequency=None, # frequency higher than this cutoff is not considered
                    cutoff_lifetime=1e-4,
                    displacement_distance=0.03,
                    diff_kappa = 1e-4, # Criterion for kappa convergence
                    delta_fc2=False,
                    factor=None,
                    delta_fc2_sets_mode=False,
                    freq_scale=None,
                    gamma_option=0,
                    grid_points=None,
                    gv_delta_q=None,
                    ion_clamped=False,
                    is_decay_channel=False,
                    is_nodiag=False,
                    is_displacement=False,
                    is_nosym=False,
                    is_gruneisen=False,
                    is_joint_dos=False,
                    is_tetrahedron_method=False,
                    is_linewidth=False,
                    is_frequency_shift=False,
                    is_ite=False,
                    is_bterta=False,
                    is_nac=False,
                    is_plusminus_displacements=False,
                    is_translational_symmetry=False,
                    is_symmetrize_fc2=False,
                    is_symmetrize_fc3_r=False,
                    is_symmetrize_fc3_q=False,                     
                    log_level=None,
                    max_freepath=None,
                    max_ite=None,
                    mesh_numbers=None,
                    mesh_divisors=None,
                    multiple_sigmas=None,
                    adaptive_sigma_step=None,
                    no_kappa_stars=False,
                    q_direction=None,
                    primitive_axis=None,
                    read_amplitude=False,
                    is_triplets_dispersed=False,
                    read_fc2=False,
                    read_fc2_extra=False,
                    read_fc3=False,
                    read_gamma=False,
                    freq_step=None,
                    input_filename=None,
                    output_filename=None,
                    qpoints=None,
                    quiet=False,
                    sigma=None,
                    supercell_dimension=None,
                    supercell_dimension_extra=None,
                    wstep=None,
                    symprec=1e-5,
                    tmax=None,
                    tmin=None,
                    tstep=None,
                    temperatures=None,
                    verbose=False,
                    uplo='L',
                    write_amplitude=False,
                    write_gamma=False,
                    length=None,
                    is_nu=False,
                    is_ise=False,
                    write_grid_points=False,
                    write_triplet=False,
                    read_scr=False,
                    write_scr=False,
                    is_thm=False,
                    write_tecplot=False)
parser.add_option("--amplitude", dest="displacement_distance", type="float",
                  help="Distance of displacements")
parser.add_option("--bi", "--band_indices", dest="band_indices",
                  type="string",
                  help="Band indices where life time is calculated")
parser.add_option("--band", dest="band_paths",
                  action="store", type="string",
                  help="Band structure paths calculated for Gruneisen parameter")
parser.add_option("--band_points", dest="band_points",
                  type="int",
                  help="Number of points calculated on a band segment in the band structure Gruneisen parameter calculation")
parser.add_option("--ite", "--iterative", dest="is_ite",
                  action="store_true",
                  help="Solve BTE iteratively")
parser.add_option("--ite_cg", "--iterative_conjugate_gradient", dest="is_ite_cg",
                  action="store_true",
                  help="Solve BTE iteratively using the conjugate gradient method")
parser.add_option("--ise", "--image_self_energy", dest="is_ise",
                  action="store_true",
                  help="Get the image self energy")
parser.add_option("--thm", "--tetrahedron_method", dest="is_tetrahedron_method",
                  action="store_true", help="Use tetrahedron method")
parser.add_option("--br", "--bterta", dest="is_bterta",
                  action="store_true",
                  help="Calculate thermal conductivity in BTE-RTA")
parser.add_option("-c", "--cell", dest="cell_poscar",
                  action="store", type="string",
                  help="Read unit cell", metavar="FILE")
parser.add_option("--cutr", dest="cutoff_radius",
                  type="string",
                  help="Cutoff radius for atoms (format: 1 2 3 4 ...) (self-interacting cutoff distance instead of radius)")
parser.add_option("--cutp", "--cutoff_pair",
                  dest="cutoff_pair", type="string",
                  help="""Cutoff distance between pairs (format: 1-1 1-2 1-3 ... 2-2 2-3 ... 3-3 ...)
                  of displaced atoms used for supercell creation with displacements and making third-order force constants""")
parser.add_option("--cutt", "--cutoff_triplet",
                  dest="cutoff_triplet",
                  type="string",
                  help="""Cutoff distance of third-order force constants. (format: 1-1-1 1-1-2 1-1-3 ... 1-2-2 1-2-2 1-2-3... )
                       Elements where any pair of atoms has larger distance than cut-off distance are set zero.""")
parser.add_option("--cutd","--cutoff_delta", dest="cutoff_delta",
                  type="float",
                  help="""Cutoff value (should be lager than 3* sigma) for gaussian smearing.
                       i.e. frequency summation larger than this value is not considered for relaxation time calculation """)
parser.add_option("--cutfreq", "--cutoff_frequency", dest="cutoff_frequency",
                  type="float",
                  help="Phonon modes below this frequency are ignored.")
parser.add_option("--cuthfreq", "--cutoff_high_frequency", dest="cutoff_hfrequency",
                  type="float",
                  help="Phonon modes larger this frequency are ignored in the thermal conductivity calculation.")
parser.add_option("--cutlt", "--cutoff_lifetime", dest="cutoff_lifetime",
                  type="float",
                  help="Cutoff lifetime in second used for thermal conductivity calculation")
parser.add_option("--diffk", dest="diff_kappa",
                  type="float",
                  help="Convergence standard of thermal conductivity (Relative error)")
parser.add_option("-d", "--disp", dest="is_displacement",
                  action="store_true",
                  help="As first stage, get least displacements")
parser.add_option("--decay", dest="is_decay_channel",
                  action="store_true", help="Calculate decay channels")
parser.add_option("--dim",
                  dest="supercell_dimension",
                  type="string",
                  help="Supercell dimension")
parser.add_option("--dim2",
                  dest="supercell_dimension_extra",
                  type="string",
                  help="Supercell dimension for extra fc2")
parser.add_option("--cf3", "--create_f3",
                  dest="forces_third_mode",
                  action="store_true",
                  help="Create FORCES_THIRD")
parser.add_option("--cdfc2", "--create_delta_fc2",
                  dest="delta_fc2_sets_mode",
                  action="store_true",
                  help="Create DELTA_FC2_SETS")
parser.add_option("--dfc2", "--delta_fc2",
                  dest="read_delta_fc2",
                  action="store_true",
                  help="Read DELTA_FC2_SETS")
parser.add_option("--factor", dest="factor", type="float",
                  help="Conversion factor to favorite frequency unit")
parser.add_option("--fc2",
                  dest="read_fc2",
                  action="store_true",
                  help="Read second order force constants")
parser.add_option("--fc2_extra",
                  dest="read_fc2_extra",
                  action="store_true",
                  help="Read extra second order force constants")
parser.add_option("--fc3",
                  dest="read_fc3",
                  action="store_true",
                  help="Read third order force constants")
parser.add_option("--freepath", dest="max_freepath", type="float",
                  help="Maximum mean free path of phonon in meter")
parser.add_option("--freq_scale", dest="freq_scale", type="float",
                  help="Scale factor is multiplied to frequencies only, i.e., changes frequencies but assumed not to change the physical unit")
parser.add_option("--freq_step", dest="freq_step", type="float",
                  help="Pitch of frequency calculated")
parser.add_option("--gamma_option", dest="gamma_option", type="int",
                  help="Option for the test of imaginary part of self energy")
parser.add_option("--gp", "--grid_points",
                  dest="grid_points",
                  type="string",
                  help="Fixed grid points where damping functions are calculated ")
parser.add_option("--gruneisen", dest="is_gruneisen",
                  action="store_true",
                  help="Calculate phonon Gruneisen parameter")
parser.add_option("--gv_delta_q", dest="gv_delta_q", type="float",
                  help="Delta-q distance used for group velocity calculation")
parser.add_option("--ion_clamped", dest="ion_clamped",
                  action="store_true",
                  help="Atoms are clamped under applied strain in Gruneisen parameter calculation")
parser.add_option("--isotope", dest="is_isotope", action="store_true",
                  help="Isotope scattering lifetime")
parser.add_option("--jdos",
                  dest="is_joint_dos",
                  action="store_true",
                  help="Calculate joint density of states")
parser.add_option("--lw", "--linewidth",
                  dest="is_linewidth",
                  action="store_true",
                  help="Calculate linewidths")
parser.add_option("--fst", "--frequency_shift",
                  dest="is_frequency_shift",
                  action="store_true",
                  help="Calculate frequency shifts")
parser.add_option("--max_ite", dest="max_ite",
                  type="int",
                  help="maximum iteration steps whether or not the convergence is reached")
parser.add_option("--md", "--mesh_divisors",
                  dest="mesh_divisors",
                  type="string",
                  help="Divisors for mesh numbers")
parser.add_option("--mesh",
                  dest="mesh_numbers",
                  type="string",
                  help="Mesh numbers")
parser.add_option("--multiple_sigmas", dest="multiple_sigmas",
                  type="string",
                  help="Multiple sigmas for smearing width used for limited functions")
parser.add_option("--adaptive_sigma_step", "--astep",dest="adaptive_sigma_step",
                  type="int",
                  help="Maximum adaptive sigma steps ( iteration for several times needed)")
parser.add_option("--mv", "--mass_variances", dest="mass_variances",
                  type="string",
                  help="Mass variance parameters for isotope scattering")
parser.add_option("--nac", dest="is_nac",
                  action="store_true",
                  help="Non-analytical term correction")
parser.add_option("--nodiag", dest="is_nodiag",
                  action="store_true",
                  help="Set displacements parallel to axes")
parser.add_option("--noks", "--no_kappa_stars", dest="no_kappa_stars",
                  action="store_true",
                  help="Deactivate summation of partial kappa at q-stars"),
parser.add_option("--nosym", dest="is_nosym",
                  action="store_true",
                  help="No symmetrization of triplets")
parser.add_option("-i",dest="input_filename",
                  type="string",
                  help="Filename of input thermal conductivity calculated through rta")
parser.add_option("-o", dest="output_filename",
                  type="string",
                  help="Filename of output of damping function")
parser.add_option("--pa", "--primitive_axis", dest="primitive_axis",
                  action="store", type="string",
                  help="Same as PRIMITIVE_AXIS tags")
parser.add_option("--pm", dest="is_plusminus_displacements",
                  action="store_true",
                  help="Set plus minus displacements")
parser.add_option("--length", dest="length",type="float",
                  help="The sample length in um considering phonon boundary scattering")
parser.add_option("--qpoints", dest="qpoints", type="string",
                  help="Calculate at specified q-points")
parser.add_option("--q_direction",
                  dest="q_direction",
                  type="string",
                  help="q-vector direction at q->0 for non-analytical term correction")
parser.add_option("-q", "--quiet", dest="quiet",
                  action="store_true",
                  help="Print out smallest information")
parser.add_option("--read_amplitude", dest="read_amplitude",
                  action="store_true",
                  help="Read phonon-phonon interaction amplitudes")
parser.add_option("--read_gamma", dest="read_gamma",
                  action="store_true",
                  help="Read Gammas from files")
parser.add_option("--sigma", dest="sigma", type="float",
                  help="Smearing width for DOS")
parser.add_option("--sym_fc2", dest="is_symmetrize_fc2",
                  action="store_true",
                  help="Symmetrize fc2 by index exchange")
parser.add_option("--sym_fc3r", dest="is_symmetrize_fc3_r",
                  action="store_true",
                  help="Symmetrize fc3 in real space by index exchange")
parser.add_option("--sym_fc3q", dest="is_symmetrize_fc3_q",
                  action="store_true",
                  help="Symmetrize fc3 in reciprocal space by index exchange")
parser.add_option("--tmax", dest="tmax", type="string",
                  help="Maximum calculated temperature")
parser.add_option("--tmin", dest="tmin", type="string",
                  help="Minimum calculated temperature")
parser.add_option("--tstep", dest="tstep", type="string",
                  help="Calculated temperature step")
parser.add_option("--wstep", dest="wstep", type=int,
                  help="Step at which kappa file is written (only applicable for iteration process)")
parser.add_option("--tsym", dest="is_translational_symmetry",
                  action="store_true",
                  help="Impose translational invariance condition")
parser.add_option("--qpermute", dest="is_qpoints_permute_symmetry",
                  action="store_true",
                  help="Impose translational invariance condition")
parser.add_option("--tolerance", dest="symprec", type="float",
                  help="Symmetry tolerance to search")
parser.add_option("-v", "--verbose", dest="verbose",
                  action="store_true",
                  help="Detailed run-time information is displayed")
parser.add_option("--loglevel", dest="log_level", type="int",
                  help="Log level")
parser.add_option("--ts", dest="temperatures", 
                  type="string", help="Temperatures for damping functions")
parser.add_option("--uplo",
                  dest="uplo",
                  type="string",
                  help="Lapack zheev UPLO")
parser.add_option("--wgp", "--write_grid_points", dest="write_grid_points",
                  action="store_true",
                  help="Write grid address of irreducible grid points for specified mesh numbers to ir_grid_address.yaml")
parser.add_option("--nu","--normal_umklapp",
                  dest="is_nu",
                  action="store_true",
                  help="Tell Normal process and Umklapp process apart in relaxation time calculation")
parser.add_option("--write_amplitude", dest="write_amplitude",
                  action="store_true",
                  help="Write phonon-phonon interaction amplitudes")
parser.add_option("--disperse", dest="is_triplets_dispersed",
                  action="store_true",
                  help="Write phonon-phonon interaction amplitudes not as a whole but to write them by each triplet")
parser.add_option("--write_gamma", dest="write_gamma",
                  action="store_true",
                  help="Write gamma")
parser.add_option("--write_triplet", dest="write_triplet",
                  action="store_true",
                  help="write triplet")
parser.add_option("--read_collision", dest="read_col",
                  action="store_true",
                  help="read the scattering rate for iterative calculation of thermal conductivity")
parser.add_option("--write_collision", dest="write_col",
                  action="store_true",
                  help="write the scattering rates")
parser.add_option("--tecplot", dest="write_tecplot",
                  action="store_true",
                  help="write the properties to tecplot format")
(options, args) = parser.parse_args()
option_list = parser.option_list


# Log level
log_level = 1
if options.verbose:
    log_level = 2
if options.quiet:
    log_level = 0
if not options.log_level==None:
    log_level=options.log_level
    
# Title
if log_level:
    print_phono3py(datetime.now())
    print_version(phono3py_version)

# Create FORCES_THIRD
if options.forces_third_mode:
    disp_dataset = parse_disp_fc3_yaml()
    write_FORCES_THIRD(args, disp_dataset)
    print_end()
    exit(0)

# Create DELTA_FC2_SETS
if options.delta_fc2_sets_mode:
    disp_dataset = parse_disp_fc3_yaml()
    write_DELTA_FC2_SETS(args, disp_dataset)
    print_end()
    exit(0)


# Import input files
if len(args) > 0:
    phono3py_conf = Phono3pyConfParser(filename=args[0],
                                       options=options,
                                       option_list=option_list)
    settings = phono3py_conf.get_settings()

else:
    phono3py_conf = Phono3pyConfParser(options=options,
                                       option_list=option_list)
    settings = phono3py_conf.get_settings()

# Read POSCAR
if options.cell_poscar == None:
    if os.path.exists('POSCAR'):
        unitcell_filename = 'POSCAR'
    else:
        print_error_message("POSCAR could not be found.")
        if log_level:
            print_end()
        sys.exit(1)
else:
    if os.path.exists(options.cell_poscar):
        unitcell_filename = options.cell_poscar
    else:
        print_error_message("The file \'%s\' could not be found." %
                    options.cell_poscar)
        if log_level:
            print_end()
        sys.exit(1)
    
unitcell = read_vasp(unitcell_filename,
                     settings.get_chemical_symbols())

# Supercell and Symmetry 
supercell = get_supercell(unitcell, settings.get_supercell_matrix())
symmetry = Symmetry(supercell, options.symprec)

if settings.get_supercell_matrix_extra() is not None:
    supercell_extra = get_supercell(unitcell, settings.get_supercell_matrix_extra())
    symmetry_extra = Symmetry(supercell_extra, options.symprec)

# Log
if log_level:
    if options.is_translational_symmetry:
        print "Translational symmetry:", options.is_translational_symmetry
    if options.is_symmetrize_fc2:
        print "FC2 symmetry of index exchange:", options.is_symmetrize_fc2
    if options.is_symmetrize_fc3_r:
        print "FC3 symmetry of index exchange in real space:", options.is_symmetrize_fc3_r
    if options.is_symmetrize_fc3_q:
        print "FC3 symmetry of index exchange in reciprocal space:", options.is_symmetrize_fc3_q
    if settings.get_cutoff_radius() is not None:
        print "Cutoff radius:"
        print settings.get_cutoff_radius()
    if settings.get_cutoff_pair() is not None:
        print "Cutoff pair distance:"
        print settings.get_cutoff_pair()
    if settings.get_cutoff_triplet() is not None:
        print "FC3 cutoff distance:",
        print settings.get_cutoff_triplet()
    if not options.supercell_dimension_extra == None:
        print "Extra supercell for fc2 is supplied."
    if settings.get_is_nac():
        print "Non-analytical term correction:", settings.get_is_nac()
    print "Spacegroup: ", symmetry.get_international_table()

specie, sequence = np.unique(unitcell.get_atomic_numbers(), return_index=True)
cutoff = Cutoff(specie[np.argsort(sequence)],
                settings.get_cutoff_radius(),
                settings.get_cutoff_pair(),
                settings.get_cutoff_triplet())


if options.is_displacement:
    run_mode = "displacements"
elif options.write_grid_points:
    run_mode = "grid_points"
elif options.write_triplet:
    run_mode = "triplets"
elif options.is_gruneisen:
    run_mode = "gruneisen"
elif options.is_joint_dos:
    run_mode = "joint_dos"
elif settings.get_is_bterta():
    run_mode = "bterta"
elif settings.get_is_ite():
    run_mode = "bteite"
elif settings.get_is_ite_cg():
    run_mode = "bteite_cg"
elif  settings.get_is_linewidth():
    run_mode = "linewidth"
elif settings.get_is_ise():
    run_mode = "image_self_energy"
elif settings.get_is_frequency_shift():
    run_mode = "frequency_shift"
elif options.is_decay_channel:
    run_mode = "decay_channel"
elif options.is_isotope:
    run_mode = "isotope"
else:
    run_mode = "matrix_contribution"


###############################################################
# Create supercells with displacements and exit (pre-process) #
###############################################################
if run_mode == "displacements":
    cutoff_pair_distance = cutoff.get_cutoff_pair()
    cutoff.set_cell(supercell, symprec = symmetry.get_symmetry_tolerance())
    cutpair_super = cutoff.expand_pair()
    displacement_dataset = get_third_order_displacements(supercell,
                                                         symmetry,
                                                         is_plusminus=settings.get_is_plusminus_displacement(),
                                                         is_diagonal=settings.get_is_diagonal_displacement())
    dds = direction_to_displacement(displacement_dataset,
                                    settings.get_displacement_distance(),
                                    supercell,
                                    cutoff_pair_distance=cutpair_super)

    num_disps, num_disp_files = write_supercells_with_displacements(supercell,
                                                                    dds,
                                                                    amplitude=settings.get_displacement_distance(),
                                                                    cutoff_distance=cutoff_pair_distance)
    if log_level:
        print "Total number of displacements:", num_disps
        if cutoff_pair_distance is not None:
            # print "Cutoff distance for displacements:",
            # for at, dist in zip(unique_atom_symbols, cutoff_pair_distance):
            #     print at, ":", dist,";",
            # print
            print "Number of displacement supercell files created:",
            print  num_disp_files
    if log_level:
        print "FORCES_FC3 has been created."
        print_end()
    exit(0)

#########################################
# Calculate third-order force constants #
#########################################
primitive = Primitive(
    supercell,
    np.dot(np.linalg.inv(settings.get_supercell_matrix()),
           settings.get_primitive_matrix()),
    options.symprec)

if not settings.get_supercell_matrix_extra()==None:
    primitive_extra = Primitive(
        supercell_extra,
        np.dot(np.linalg.inv(settings.get_supercell_matrix_extra()),
               settings.get_primitive_matrix()),
        options.symprec)



if log_level:
    print "------------------------ primitive cell for fc ---------------------------"
    print_cell(primitive)
    print "-------------------------- supercell for fc ------------------------------"
    print_cell(supercell, mapping=primitive.get_supercell_to_primitive_map())
    print "----------------- ratio (supercell for fc)/(primitive) -------------------"
    for vec in np.dot(supercell.get_cell(), np.linalg.inv(primitive.get_cell())):
        print "%5.2f"*3 % tuple(vec)
if log_level and (not settings.get_supercell_matrix_extra()==None):
    print "------------------------- primitive cell extra ----------------------------"
    print_cell(primitive_extra)
    print "--------------------------- supercell extra -------------------------------"
    print_cell(supercell_extra, mapping=primitive_extra.get_supercell_to_primitive_map())
    print "--------------- ratio (supercell extra)/(primitive  extra) ----------------"
    for vec in np.dot(supercell_extra.get_cell(),
                       np.linalg.inv(primitive_extra.get_cell())):
        print "%5.2f"*3 % tuple(vec)

# Write ir-grid points
if run_mode == "grid_points":
    print "---------------------------------------------------------------------------"
    mesh = settings.get_mesh_numbers()
    if mesh is None:
        print_error_message("To write grid points, mesh numbers have to be specified.")
        print_error()
        sys.exit(1)
    else:
        print "Ir-grid points are written into ir_grid_points.yaml."
        mesh_divs = settings.get_mesh_divisors()
        (grid_points,
         coarse_grid_weights,
         grid_address) = get_coarse_ir_grid_points(
            primitive,
            mesh,
            mesh_divs,
            settings.get_coarse_mesh_shifts())
        write_ir_grid_points(mesh,
                             mesh_divs,
                             grid_points,
                             coarse_grid_weights,
                             grid_address)
        sys.exit(0)

if run_mode == "triplets":
    mesh=settings.get_mesh_numbers()
    if options.grid_points is None:
        grid_points = None
    else:
        grid_points = np.array(
            [int(x) for x in options.grid_points.replace(',', ' ').split()])
    if mesh is None:
        print "To write triplets, mesh numbers have to be specified."
    if grid_points is None:
        print "grid point has to be specified to get triplets "
    else:
        print "Writing triplets..."
        sym=Symmetry(primitive)
        point_group_oprations=sym.get_pointgroup_operations()
        for grid_point in grid_points:
            if options.is_nosym:
                triplets_at_q, weights_at_q, grid_address = get_nosym_triplets_at_q(grid_point, mesh, primitive.get_cell())
            else:
                (triplets_at_q,
                 weights_at_q,
                 grid_address)=get_triplets_at_q(grid_point,
                                                 mesh,
                                                 point_group_oprations,
                                                 primitive.get_cell())
            write_triplets(triplets_at_q, weights_at_q, mesh, grid_address, grid_point)
    sys.exit(0)

# fc2
if settings.get_read_fc2() or options.read_delta_fc2:
    if log_level:
        print  "----- Read fc2 -----"
        sys.stdout.flush()
    if os.path.exists('fc2.hdf5'):
        fc2_with_dim = read_fc2_from_hdf5()
    elif os.path.exists('force_constants.hdf5'):
        fc2_with_dim = read_fc2_from_hdf5(filename='force_constants.hdf5')
    else:
        print "fc2.hdf5 not found"
        if log_level:
            print_end()
        sys.exit(0)
else:
    if log_level:
        print "----- Solve fc2 -----"
        sys.stdout.flush()

    disp_dataset = parse_disp_fc3_yaml()
    forces_second = parse_FORCES_SECOND(disp_dataset)
    fc2_with_dim = get_force_constants(forces_second,
                                       symmetry,
                                       supercell)

if options.is_symmetrize_fc2:
    set_permutation_symmetry(fc2_with_dim)

if options.is_translational_symmetry:
    set_translational_invariance(fc2_with_dim)

show_drift_force_constants(fc2_with_dim, name='fc2')

if not settings.get_read_fc2():
    if log_level:
        print "----- Write fc2.hdf5 -----"
    write_fc2_to_hdf5(fc2_with_dim)



if settings.get_supercell_matrix_extra()==None:
    fc2 = fc2_with_dim
else:
    # fc2 extra (FORCE_SETS_EXTRA)
    if settings.get_read_fc2_extra():
        if log_level:
            print "----- Read fc2 extra -----"
            sys.stdout.flush()

        fc2 = read_fc2_from_hdf5(filename='fc2_extra.hdf5')
    else:
        if log_level:
            print "----- Solve fc2 extra -----"
            sys.stdout.flush()

        forces_second_extra = parse_FORCE_SETS(
            supercell_extra.get_number_of_atoms(),
            filename="FORCE_SETS_EXTRA")
        fc2 = get_force_constants(forces_second_extra,
                                  symmetry_extra,
                                  supercell_extra)

    if options.is_symmetrize_fc2:
        set_permutation_symmetry(fc2)

    if options.is_translational_symmetry:
        set_translational_invariance(fc2)

    show_drift_force_constants(fc2, 'fc2_extra')

    if not settings.get_read_fc2_extra():
        if log_level:
            print "----- Write fc2_extra.hdf5 -----"
        write_fc2_to_hdf5(fc2, filename='fc2_extra.hdf5')

if settings.get_is_nac():
    if os.path.exists('BORN'):
        if settings.get_supercell_matrix_extra()==None:
            nac_params = parse_BORN(primitive)
        else:
            nac_params = parse_BORN(primitive_extra)

        nac_q_direction = settings.get_q_direction()
    else:
        print_error_message("BORN not found")
        if log_level:
            print_end()
        sys.exit(1)
else:
    nac_params = None
    nac_q_direction = None

# fc3
if (options.is_joint_dos or
        (settings.get_read_gamma() and settings.get_is_bterta()) or
        run_mode == "isotope" or
        settings.get_read_amplitude() or
        (options.read_col and settings.get_adaptive_sigma_step() == 0)):
    fc3 = None
    atom_triplet_cut=None
else:
    if settings.get_read_fc3(): # Read fc3.hdf5
        if log_level:
            print  "----- Read fc3 -----"
            sys.stdout.flush()
        fc3 = read_fc3_from_hdf5()
    else: # fc3 from FORCES_THIRD and FORCES_SECOND
        if log_level:
            print  "----- Solve fc3 -----"
            sys.stdout.flush()

        disp_dataset = parse_disp_fc3_yaml()
        if options.read_delta_fc2:
            parse_DELTA_FC2_SETS(disp_dataset)
        else:
            parse_DELTA_FORCES(disp_dataset)
        if "cutoff_distance" in disp_dataset:
            fc3 = get_fc3(
                supercell,
                disp_dataset,
                fc2_with_dim,
                symmetry,
                verbose=log_level)
            if log_level:
                print "Cutting-off pair:",  disp_dataset['cutoff_distance']
            cutoff_fc3(fc3,
                       supercell,
                       disp_dataset,
                       symmetry,
                       verbose=log_level)
        else:
            fc3 = get_fc3(
                supercell,
                disp_dataset,
                fc2_with_dim,
                symmetry,
                is_translational_symmetry=options.is_translational_symmetry,
                is_permutation_symmetry=options.is_symmetrize_fc3_r,
                verbose=log_level)

    # fc3 is cut-off by the distances among atoms and replaced by zero.
    cutoff.set_cell(supercell, symprec = symmetry.get_symmetry_tolerance())
    atom_triplet_cut = (cutoff.get_triplet_inclusion()==False) # is_cut and is_include
    if not np.alltrue(cutoff.get_triplet_inclusion()):
        print "fc3 beyond the cutoff is set as zero"
        cutoff_fc3_by_zero(fc3, cutoff.get_triplet_inclusion())
        show_drift_fc3(fc3)
    # Symmetrize fc3_r
    if options.is_symmetrize_fc3_r:
        if log_level:
            print "----- Symmetrize fc3 real space -----"
        set_permutation_symmetry_fc3(fc3)

    if options.is_translational_symmetry:
        print "----- Symmetrize fc3 from translational symmetry -----"
        set_translational_invariance_fc3(fc3)

    show_drift_fc3(fc3)

    # Write fc3
    if not settings.get_read_fc3():
        if log_level:
            print "----- Write fc3.hdf5 -----"
        write_fc3_to_hdf5(fc3)

#============================
# Phonon Gruneisen parameter
#============================
if run_mode=='gruneisen':
    mesh = settings.get_mesh_numbers()
    band_paths = settings.get_bands()
    qpoints = settings.get_qpoints()
    ion_clamped = settings.get_ion_clamped()

    if (mesh is None and
        band_paths is None and
        qpoints is None):
        if log_level:
            print "An option of --mesh, --band, or --qpoints has to be specified."
            sys.exit(1)

    if log_level:
        print "------ Phonon Gruneisen parameter ------"
        if mesh is not None:
            print "Mesh:", mesh
        elif band_paths is not None:
            print "Paths in reciprocal reduced coordinates:"
            for path in band_paths:
                print ("[%5.2f %5.2f %5.2f] --> [%5.2f %5.2f %5.2f]" %
                       (tuple(path[0]) + tuple(path[-1])))
        if ion_clamped:
            print "To be calculated with ion clamped."

        sys.stdout.flush()
    if  settings.get_supercell_matrix_extra() == None:
        supercell_extra = None
    gr = get_gruneisen_parameters(fc2,
                                  fc3,
                                  supercell,
                                  primitive,
                                  supercell_extra = supercell_extra,
                                  nac_params=nac_params,
                                  nac_q_direction=nac_q_direction,
                                  ion_clamped=ion_clamped,
                                  factor=VaspToTHz,
                                  symprec=options.symprec)
    if mesh is not None:
        gr.set_sampling_mesh(mesh,
                             settings.get_coarse_mesh_shifts())

    elif band_paths is not None:
        gr.set_band_structure(band_paths)
    elif qpoints is not None:
        gr.set_qpoints(qpoints)
    gr.run_at_sigma_and_temp()
    gr.write_yaml()
    if log_level:
        print_end()
        exit(0)


#===========================
# Initialization
#===========================
mesh = settings.get_mesh_numbers()
if mesh is None:
    print_error_message("Mesh not given!")
    print_error()
    sys.exit(1)

if options.grid_points is None:
    grid_points = None
else:
    grid_points = np.array(
        [int(x) for x in options.grid_points.replace(',', ' ').split()])

if options.factor is None:
    factor = VaspToTHz
else:
    factor = options.factor

freq_factor = 1.0

sigma = settings.get_sigma()

if settings.get_multiple_sigmas() is None:
    if settings.get_is_tetrahedron_method():
        multiple_sigmas = [None]
    elif sigma is not None:
        multiple_sigmas = [sigma]
    else:
        multiple_sigmas = [0.1]
else:
    multiple_sigmas = settings.get_multiple_sigmas()

if settings.get_omega_step() is None:
    freq_step = 0.1 * freq_factor
else:
    freq_step = settings.get_omega_step()

if options.freq_scale is None:
    freq_scale = 1.0
else:
    freq_scale = options.freq_scale

if settings.get_supercell_matrix_extra() is None:
    supercell_dm = supercell
    primitive_dm = primitive
else:
    supercell_dm = supercell_extra
    primitive_dm = primitive_extra

if settings.get_temperatures() is None:
    if options.is_joint_dos:
        temperatures = None
    else:
        tmin = settings.get_min_temperature()
        tmax = settings.get_max_temperature()
        tstep = settings.get_temperature_step()
        temperatures = np.arange(tmin, tmax + tstep / 2.0, tstep)
else:
    temperatures = settings.get_temperatures()

if log_level:
    print "------ Settings ------"
    print "Mesh sampling: [ %d %d %d ]" % tuple(mesh)
    if grid_points is not None:
        print "Grid points to be calculated:", grid_points
    sys.stdout.flush()

if run_mode == "joint_dos":
    joint_dos = JointDOS(
        supercell_dm,
        primitive_dm,
        mesh,
        fc2,
        nac_params=nac_params,
        nac_q_direction=nac_q_direction,
        sigmas=multiple_sigmas,
        cutoff_frequency=settings.get_cutoff_frequency(),
        frequency_step=freq_step,
        frequency_factor_to_THz=factor,
        frequency_scale_factor=freq_scale,
        temperatures=temperatures,
        is_nosym=options.is_nosym,
        symprec=options.symprec,
        log_level=log_level)
    joint_dos.run(grid_points)
    if log_level:
        print_end()
    sys.exit(0)
######################
# Isotope scattering #
######################
if options.is_isotope and settings.get_mass_variances() is None:
    from phonopy.structure.atoms import isotope_data
    symbols = primitive_dm.get_chemical_symbols()
    in_database = True
    for s in set(symbols):
        if not s in isotope_data:
            print "%s is not in the list of isotope databese" % s,
            print "(not implemented)."
            print "Use --mass_variances option."
            in_database = False
    if not in_database:
        if log_level:
            print_end()
        sys.exit(0)

if options.is_isotope or settings.get_mass_variances() is not None:
    mass_variances = settings.get_mass_variances()
    if mass_variances is not None:
        mass_variances = np.array(mass_variances, dtype="double")
        if len(mass_variances)!=primitive.get_number_of_atoms():
            spec, rev_map=np.unique(primitive.get_masses(), return_inverse=True)
            assert(len(mass_variances) == len(spec))
            mass_variances=mass_variances[rev_map]
    else:
        from anharmonic.other.isotope import get_mass_variances
        mass_variances = get_mass_variances(primitive_dm)
else:
    mass_variances = None


if run_mode == "isotope":
    band_indices=settings.get_band_indices()
    if band_indices is not None:
        band_indices = np.hstack(band_indices).astype('intc')
    else:
        band_indices=np.arange(primitive.get_number_of_atoms()*3).astype("intc")
    phono3pyiso = Phono3pyIsotope(
        mesh,
        primitive_dm,
        mass_variances,
        band_indices=band_indices,
        sigmas=multiple_sigmas,
        frequency_factor_to_THz=factor,
        symprec=options.symprec,
        cutoff_frequency=settings.get_cutoff_frequency(),
        lapack_zheev_uplo=options.uplo,
        temperatures=temperatures)
    phono3pyiso.set_dynamical_matrix(fc2,
                             supercell_dm,
                             primitive_dm,
                             nac_params=nac_params)

    phono3pyiso.run(grid_points)
    if log_level:
        print_end()
    sys.exit(0)

if log_level:
    print "Cutoff frequency:", settings.get_cutoff_frequency()
cutoff.set_cell(primitive,symprec=symmetry.get_symmetry_tolerance())
cutoff_fc3q = (cutoff.get_triplet_inclusion()==False)
if settings.get_band_indices() is None:
    band_indices = [range(primitive.get_number_of_atoms() * 3)]
else:
    band_indices = settings.get_band_indices()
band_indices_flatten = np.intc([x for bi in band_indices for x in bi])

interaction = Interaction(
    fc3,
    supercell,
    primitive,
    mesh,
    band_indices=band_indices_flatten,
    frequency_factor_to_THz=factor,
    symprec=options.symprec,
    atom_triplet_cut = atom_triplet_cut,
    cutoff_fc3q = cutoff_fc3q,
    cutoff_frequency=settings.get_cutoff_frequency(),
    cutoff_hfrequency=settings.get_cutoff_hfrequency(),
    cutoff_delta = settings.get_cutoff_delta(),
    is_nosym=options.is_nosym,
    symmetrize_fc3_q=options.is_symmetrize_fc3_q,
    is_triplets_dispersed=options.is_triplets_dispersed,
    is_write_amplitude=settings.get_write_amplitude(),
    is_read_amplitude=settings.get_read_amplitude(),
    lapack_zheev_uplo=options.uplo)


phono3py = Phono3py(interaction,
                    mass_variances=mass_variances,
                    length=settings.get_length(),
                    adaptive_sigma_step=settings.get_adaptive_sigma_step(),
                    frequency_factor_to_THz=factor,
                    is_nosym=options.is_nosym,
                    symprec=options.symprec,
                    log_level=log_level,
                    write_tecplot=options.write_tecplot,
                    is_thm = settings.get_is_tetrahedron_method())

phono3py.set_dynamical_matrix(fc2,
                              supercell_dm,
                              primitive_dm,
                              nac_params=nac_params,
                              nac_q_direction=nac_q_direction,
                              frequency_scale_factor=freq_scale)
if options.is_isotope:
    phono3py.set_dynamical_matrix(fc2,
                             supercell_dm,
                             primitive_dm,
                             nac_params=nac_params)

if run_mode == "decay_channel":
    phono3py.get_decay_channels(grid_points=grid_points,
                                sets_of_band_indices=settings.get_band_indices(),
                                sigmas=multiple_sigmas,
                                read_amplitude=settings.get_read_amplitude(),
                                temperature=temperatures,
                                filename=options.output_filename)
elif run_mode=="linewidth":
    phono3py.get_linewidth(
        grid_points,
        sigmas=multiple_sigmas,
        temperatures=temperatures,
        read_amplitude=settings.get_read_amplitude(),
        is_nu=settings.get_is_nu(),
        band_paths= settings.get_bands(),
        filename=options.output_filename)
elif run_mode=="image_self_energy":
    phono3py.get_imag_self_energy(
        grid_points,
        frequency_step=freq_step,
        sigmas=multiple_sigmas,
        temperatures=temperatures,
        filename=options.output_filename)
elif run_mode == "frequency_shift":
    phono3py.get_frequency_shift(
        grid_points,
        epsilon=sigma,
        temperatures=temperatures,
        filename=options.output_filename)
elif run_mode == "bterta":
    phono3py.get_thermal_conductivity(
        sigmas=multiple_sigmas,
        temperatures=temperatures,
        grid_points=grid_points,
        mesh_divisors=settings.get_mesh_divisors(),
        coarse_mesh_shifts=settings.get_coarse_mesh_shifts(),
        cutoff_lifetime=settings.get_cutoff_lifetime(),
        diff_kappa= settings.get_diff_kappa(),
        is_nu=settings.get_is_nu(),
        no_kappa_stars=settings.get_no_kappa_stars(),
        gv_delta_q=settings.get_group_velocity_delta_q(),
        write_gamma=settings.get_write_gamma(),
        read_gamma=settings.get_read_gamma(),
        kappa_write_step=settings.get_kappa_write_step(),
        filename=options.output_filename)
elif run_mode=="bteite":
    if settings.get_min_temperature()<=0:
        print_error_message("Error: The iterative method can only be applied for T>0K")
        print_end()
        sys.exit(1)
    phono3py.get_kappa_ite(
        sigmas=multiple_sigmas,
        temperatures=temperatures,
        grid_points=grid_points,
        max_ite = settings.get_max_ite(),
        no_kappa_stars=settings.get_no_kappa_stars(),
        diff_kappa = settings.get_diff_kappa(),
        write_gamma=settings.get_write_gamma(),
        read_gamma=settings.get_read_gamma(),
        read_col = options.read_col,
        write_col = options.write_col,
        filename=options.output_filename)
elif run_mode=="bteite_cg":
    if settings.get_min_temperature()<=0:
        print_error_message("Error: The iterative method can only be applied for T>0K")
        print_end()
        sys.exit(1)
    phono3py.get_kappa_ite_cg(
        sigmas=multiple_sigmas,
        temperatures=temperatures,
        grid_points=grid_points,
        max_ite = settings.get_max_ite(),
        no_kappa_stars=settings.get_no_kappa_stars(),
        diff_kappa = settings.get_diff_kappa(),
        write_gamma=settings.get_write_gamma(),
        read_gamma=settings.get_read_gamma(),
        read_col = options.read_col,
        write_col = options.write_col,
        filename=options.output_filename)
elif run_mode=="matrix_contribution":
    phono3py.get_matrix_contribution(
        grid_points,
        frequency_step=freq_step,
        sigmas=multiple_sigmas,
        filename=options.output_filename)

if log_level:
    print_end(datetime.now())
